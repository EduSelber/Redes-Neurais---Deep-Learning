{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"data/","title":"Atividade: 1. Data","text":""},{"location":"data/#exercicio-1-exploring-class-separability-in-2d","title":"Exerc\u00edcio 1 \u2014 Exploring Class Separability in 2D","text":""},{"location":"data/#a-brief-description-of-my-approach","title":"A brief description of my approach","text":"<p>Para gerar os dados, utilizo distribui\u00e7\u00f5es normais multivariadas com a fun\u00e7\u00e3o random.multivariate_normal do numpy, cada um com m\u00e9dia e covari\u00e2ncia diferentes. Cada ponto recebe um r\u00f3tulo de classe correspondente ao cluster de origem.</p>"},{"location":"data/#generate-the-data","title":"Generate  the data:","text":"<pre><code>data = {'x': [], 'y':[], 'class':[], 'color': []}\n\n\nmean_std_dev = [([2,3], np.diag([0.8, 2.5])) ,\n([5,6], np.diag([1.2, 1.9])),\n([8,1], np.diag([0.9, 0.9])),\n([15,4], np.diag([0.5, 2.0]))]\nmean = [2, 3]\ncov = np.diag([0.8, 2.5])\nfor i in range(0, 4):\n\n    mean = mean_std_dev[i][0]\n    cov = mean_std_dev[i][1]\n\n    x, y = np.random.multivariate_normal(mean, cov, 100).T\n    classe = []\n    for c in range(0, len(x)):\n        data['x'].append(x[c])\n        data['y'].append(y[c])\n        data['class'].append(f\"class_{i}\")\n        if i == 0:\n            data['color'].append((1.0, 0.0, 0.0))\n        if i == 1:\n            data['color'].append((1.0,0.0,1.0,))\n        if i == 2:\n            data['color'].append((1.0, 1.0, 0.0))\n        if i == 3:\n            data['color'].append((1.0, 0.5, 0.5))\n</code></pre>"},{"location":"data/#ploting-the-data","title":"Ploting the Data","text":""},{"location":"data/#analyze-and-draw-boundaries","title":"Analyze and Draw Boundaries","text":"<p>a .No gr\u00e1fico de dispers\u00e3o, observa-se que as duas classes mais \u00e0 direita (rosa claro) est\u00e3o bem separadas das demais, sem sobreposi\u00e7\u00e3o aparente. J\u00e1 as duas classes mais \u00e0 esquerda (vermelha e roxa) apresentam consider\u00e1vel sobreposi\u00e7\u00e3o em suas regi\u00f5es, tornando dif\u00edcil distingui-las linearmente. A classe amarela encontra-se abaixo, relativamente bem delimitada, embora mais pr\u00f3xima das classes vermelha e roxa.</p> <p>b. Observando o plot, seriam necess\u00e1rias tr\u00eas fronteiras lineares para separar corretamente todas as classes. Com apenas uma, seria poss\u00edvel dividir em metades (esquerda e direita), mas cada lado ainda conteria duas classes. Com duas fronteiras, ainda restaria um lado com duas classes agrupadas. Assim, somente com uma terceira linha seria poss\u00edvel separar essas duas classes restantes.</p> <p>c.</p>"},{"location":"data/#_1","title":"1.Data","text":""},{"location":"data/#exercicio-2-non-linearity-in-higher-dimensions","title":"Exerc\u00edcio 2 \u2014 Non-Linearity in Higher Dimensions","text":""},{"location":"data/#a-brief-description-of-my-approach_1","title":"A brief description of my approach","text":"<p>Para geras os dados em cinco dimens\u00f5es foi utilizados distribui\u00e7\u00f5es normais multivariadas, cada um com atributos diferentes. Cada amostra recebeu um rotulo de classe (A ou B), dependendo da origem dela.</p>"},{"location":"data/#generate-the-data_1","title":"Generate  the data:","text":"<pre><code>import numpy as np\nimport pandas as pd\n\nrng = np.random.default_rng(42)\ndata = {\n    'x1': [], 'x2': [], 'x3': [], 'x4': [], 'x5': [],\n    'class': [], 'color': []\n}\nparams = [\n    (\n        np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n        np.array([\n            [1.0, 0.8, 0.1, 0.0, 0.0],\n            [0.8, 1.0, 0.3, 0.0, 0.0],\n            [0.1, 0.3, 1.0, 0.5, 0.0],\n            [0.0, 0.0, 0.5, 1.0, 0.2],\n            [0.0, 0.0, 0.0, 0.2, 1.0],\n        ]),\n        \"class_A\",\n        (1.0, 0.0, 0.0), \n    ),\n    (\n        np.array([1.5, 1.5, 1.5, 1.5, 1.5]),\n        np.array([\n            [1.5, -0.7, 0.2, 0.0, 0.0],\n            [-0.7, 1.5, 0.4, 0.0, 0.0],\n            [0.2, 0.4, 1.5, 0.6, 0.0],\n            [0.0, 0.0, 0.6, 1.5, 0.3],\n            [0.0, 0.0, 0.0, 0.3, 1.5],\n        ]),\n        \"class_B\",\n        (0.0, 0.0, 1.0), \n    ),\n]\n\nn_per_class = 500\n\nfor mean, cov, label, color in params:\n    samples = rng.multivariate_normal(mean, cov, size=n_per_class)\n    for s in samples:\n        data['x1'].append(s[0])\n        data['x2'].append(s[1])\n        data['x3'].append(s[2])\n        data['x4'].append(s[3])\n        data['x5'].append(s[4])\n        data['class'].append(label)\n        data['color'].append(color)\n\n\ndf = pd.DataFrame(data)\n</code></pre>"},{"location":"data/#visualize-the-data","title":"Visualize the data","text":""},{"location":"data/#analyze-the-plot","title":"Analyze the plot","text":"<p>a. Observando o gr\u00e1fico, percebe-se que os pontos vermelhos tendem a se concentrar mais \u00e0 esquerda, enquanto os azuis ficam predominantemente \u00e0 direita. No entanto, h\u00e1 uma sobreposi\u00e7\u00e3o consider\u00e1vel: v\u00e1rios pontos vermelhos aparecem em regi\u00f5es azuis e vice-versa. Isso significa que uma simples linha no meio do gr\u00e1fico n\u00e3o conseguiria separar as classes com boa acur\u00e1cia, j\u00e1 que h\u00e1 mistura entre elas.</p> <p>b. Esse tipo de dado imp\u00f5e um desafio, pois um modelo linear teria dificuldade em capturar esses casos de sobreposi\u00e7\u00e3o. Seriam necess\u00e1rias m\u00faltiplas fronteiras lineares para tentar contornar o problema, o que aumenta o risco de overfitting. Por isso, uma rede neural com m\u00faltiplas camadas e fun\u00e7\u00f5es de ativa\u00e7\u00e3o n\u00e3o lineares se mostra mais adequada, j\u00e1 que consegue modelar fronteiras de decis\u00e3o complexas e lidar melhor com regi\u00f5es de interse\u00e7\u00e3o entre as classes.</p>"},{"location":"data/#exercicio-3-preparing-real-world-data-for-a-neural-network","title":"Exerc\u00edcio 3 \u2014 Preparing Real-World Data for a Neural Network","text":""},{"location":"data/#a-brief-description-of-my-approach_2","title":"A brief description of my approach","text":"<p>Carrego o dataset e realizo o tratamento dos valores faltantes, usando a mediana para vari\u00e1veis num\u00e9ricas, a moda para vari\u00e1veis bin\u00e1rias e preenchendo as categ\u00f3ricas com \"Unknown\".</p> <p>Em seguida, aplico one-hot encoding nas vari\u00e1veis categ\u00f3ricas e normalizo os atributos num\u00e9ricos para a faixa [-1, 1].</p>"},{"location":"data/#describe-the-data","title":"Describe the Data","text":"<ul> <li> <p>O objetivo do dataset \"Spaceship Titanic\" \u00e9 prever se os passageiros foram transportados para outra dimens\u00e3o. A coluna \"Transported\" representa esse resultado: valor 1 indica que o passageiro foi transportado e valor 0 indica que n\u00e3o foi.</p> </li> <li> <p>Features num\u00e9ricas: Age, RoomService, FoodCourt, ShoppingMall, Spa, VRDeck.</p> </li> <li> <p>Features categ\u00f3ricas: PassengerId, HomePlanet, CryoSleep, Cabin, Destination, VIP, Name.</p> </li> <li> <p>Valores faltantes por coluna:</p> </li> </ul> Coluna N\u00ba de faltantes CryoSleep 217 ShoppingMall 208 VIP 203 HomePlanet 201 Name 200 Cabin 199 VRDeck 188 FoodCourt 183 Spa 183 Destination 182 RoomService 181 Age 179"},{"location":"data/#preprocess-the-data","title":"Preprocess the Data","text":"<pre><code>def report_missing(df):\n    miss = df.isna().sum()\n    miss = miss[miss &gt; 0].sort_values(ascending=False)\n    print(\"\\nFaltantes por coluna:\\n\" + (miss.to_string() if len(miss) else \"Nenhum\"))\n    return miss\n\ndef one_hot_manual(series, prefix=None):\n    s = series.astype(\"category\")\n    cats = list(s.cat.categories)\n    out = pd.DataFrame(index=series.index)\n    for c in cats:\n        col = f\"{prefix or series.name}__{c}\"\n        out[col] = (s == c).astype(int)\n    return out\n\ndef minmax_pm1_df(df, cols):\n    mn = df[cols].min(axis=0)\n    mx = df[cols].max(axis=0)\n    denom = (mx - mn).replace(0, 1.0)\n    scaled = 2 * ((df[cols] - mn) / denom) - 1\n    return scaled, mn, mx\n\n\ndef prepare_spaceship_norm(path=CSV_PATH):\n    df = pd.read_csv(path)\n    print(\"Carregado:\", path, \"shape:\", df.shape)\n\n    num_cols = [\"Age\", \"RoomService\", \"FoodCourt\", \"ShoppingMall\", \"Spa\", \"VRDeck\"]\n    bin_cols = [\"CryoSleep\", \"VIP\"]           \n    cat_cols = [\"HomePlanet\", \"Destination\"]   \n    target = \"Transported\"\n    for c in num_cols:\n        df[c] = pd.to_numeric(df[c], errors=\"coerce\")\n\n    y = df[target].astype(int)\n\n    report_missing(df)\n    for c in num_cols:\n        df[c] = df[c].fillna(df[c].median())\n    for c in bin_cols:\n        m = df[c].mode(dropna=True)\n        fill = m.iloc[0] if len(m) else False\n        df[c] = df[c].fillna(fill).map({True: 1, False: 0}).astype(int)\n    for c in cat_cols:\n        df[c] = df[c].fillna(\"Unknown\").astype(str)\n\n    oh_parts = [one_hot_manual(df[c], prefix=c) for c in cat_cols]\n    X_cat = pd.concat(oh_parts, axis=1)\n    X_num_scaled, mn, mx = minmax_pm1_df(df, num_cols)\n\n    X = pd.concat([X_num_scaled[num_cols], df[bin_cols].astype(int), X_cat], axis=1)\n    print(\"Features finais:\", X.shape)\n\n    plt.figure(figsize=(6,4)); df[\"Age\"].plot.hist(bins=30, alpha=0.85)\n    plt.title(\"Age \u2014 ANTES (valor bruto)\"); plt.xlabel(\"Age\"); plt.tight_layout()\n\n    plt.figure(figsize=(6,4)); X_num_scaled[\"Age\"].plot.hist(bins=30, alpha=0.85)\n    plt.title(\"Age \u2014 DEPOIS (normalizado [-1,1])\"); plt.xlabel(\"Age norm.\"); plt.tight_layout()\n\n    plt.figure(figsize=(6,4)); df[\"FoodCourt\"].plot.hist(bins=30, alpha=0.85)\n    plt.title(\"FoodCourt \u2014 ANTES (valor bruto)\"); plt.xlabel(\"Gasto\"); plt.tight_layout()\n\n    plt.figure(figsize=(6,4)); X_num_scaled[\"FoodCourt\"].plot.hist(bins=30, alpha=0.85)\n    plt.title(\"FoodCourt \u2014 DEPOIS (normalizado [-1,1])\"); plt.xlabel(\"Gasto norm.\"); plt.tight_layout()\n\n    plt.show()\n    return X, y, {\"min\": mn, \"max\": mx}\n</code></pre>"},{"location":"data/#visualize-the-results","title":"Visualize the Results","text":""},{"location":"data/#referencias","title":"Refer\u00eancias","text":"<ul> <li>Descri\u00e7\u00e3o do Spaceship Titanic e do alvo <code>Transported</code>: https://www.kaggle.com/competitions/spaceship-titanic/data.  </li> </ul>"}]}